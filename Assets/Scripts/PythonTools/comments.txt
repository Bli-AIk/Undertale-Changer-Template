File: Battle\BattlePlayerController.cs
Line 7: ///<summary>
Line 8: ///Control the relevant properties of the player (heart) in the battle
Line 9: ///</summary>
Line 15: [Header("Ding animation speed when the heart changes color, 0 is off")]
Line 17: [Header("Heart gradient animation speed, 0 is off")]
Line 20: [Header("Basic property adjustment")]
Line 22: //Speed ​​and weight (by multiplying X by multiples), speed test is 3, weight 0.5f
Line 24: //Invincible time
Line 25: //Collision distance judgment
Line 26: //Used for blue-orange bone judgment: whether the player is really moving
Line 38: //Direction
Line 40: //Whether it is in the "jump" state
Line 41: //Jump acceleration
Line 42: //Ray distance
Line 46: //Circular collision body
Line 48: //Color with attributes Read enum PlayerColor in BattleControl. Color transformation is performed through specific transformation functions
Line 53: //LayerMask mask;
Line 70: //mask = 1 << 6;
Line 114: //Debug
Line 172: //Reverse detection (head)
Line 174: //------------------------Move------------------------
Line 338: /////////////////////////////////////////////////////
Line 411: /// ... ////Debug.Log("Y:" + y);
Line 661: //Speed ​​reference: 3
Line 676: //Blue heart touches the board to ensure that it can jump again
Line 702: ///<summary>
Line 703: ///Fall out
Line 704: ///</summary>
Line 713: ///<summary>
Line 714: ///Change the player's color through gradient animation.
Line 715: ///If gradientTime/dingTime is equal to 0, there will be no gradient animation/ding animation;
Line 716: ///If gradientTime/dingTime is less than 0, the gradientTime/dingTime variables in the script are used.
Line 717: ///If the PlayerColor input is nullColor, the actual color attribute of the player will not be changed.
Line 718: ///</summary>
Line 778: ///<summary>
Line 779: ///Let the blue heart fall
Line 780: ///</summary>
Line 808: /// ... //Calculate the vector of the line segment
Line 830: //Get the length of the line segment
Line 831: //Standardize the line segment vector
Line 833: //Calculate the vector from the point to the starting point of the line segment
Line 834: //Calculate the projection length of the point on the line segment vector
Line 835: //Limit the projection length between 0 and the line segment length
Line 836: //Calculate and return the coordinates of the nearest point
Line 839: //Define the method for calculating the position of the vertical point after displacement
Line 842: //Calculate the direction vector of the line segment
Line 843: //Calculate the vertical direction vector (rotate 90 degrees counterclockwise)
Line 845: //Calculate and return the position of the vertical point after displacement
Line 848: //Define the method for calculating the vertices of the indented polygon
Line 851: //If the vertex list is empty or less than 3, return null
Line 853: //Initialize the list of vertices stored after displacement
Line 854: //Initialize the list of intersection points
Line 856: //Get the number of vertices
Line 859: //Get the current vertex
Line 860: //Get the next vertex (ring list)
Line 862: //Calculate the direction vector of the edge
Line 863: //Calculate the vertical direction vector
Line 865: //Calculate the displacement of the current vertex
Line 866: //Calculate the displacement of the next vertex
Line 868: //Add the current vertex after displacement to the list
Line 869: //Add the next vertex after displacement to the list
Line 871: //Calculate the intersection starting from the second edge
Line 876: //If the intersection is found, add it to the intersection list
Line 881: //Calculate the intersection of the first and last edges
Line 885: //If the intersection is found, add it to the intersection list
Line 888: //Return the intersection list, that is, the vertices of the indented polygon
Line 891: //Define the method of calculating line-line intersections
Line 894: //Initialize the intersection coordinates
Line 896: //Calculate the denominator
Line 897: //If the denominator is 0, the line segments are parallel or overlapped, and there is no intersection
Line 900: //Calculate the X coordinate of the intersection
Line 901: //Calculate the Y coordinate of the intersection
Line 903: //Return true, indicating that the intersection is found
Line 905: //Define a method to check and adjust the point position based on the displacement
Line 908: //Save the original point position
Line 910: //Check whether the recursive limit is reached
Line 912: //If the maximum number is reached, return the current point
Line 915: //Traverse all battle boxes
Line 917: //Exclude different Z axes
Line 925: //Calculate the scaled polygon vertices
Line 927: //Traverse the moved vertices
Line 929: //Debug.Log(item); //Record log
Line 932: //If the point is inside the adjusted polygon
Line 934: //Debug.Log(point, "#FF00FF"); //Record log
Line 935: //Return original coordinates
Line 939: //If the point is not in the adjusted polygon
Line 941: //Nearest point
Line 944: //Set the closest distance to the maximum value
Line 945: //Determine whether the box is a composite box. If so, adjust the moving distance
Line 947: //Traverse all battle boxes
Line 949: //Exclude those with different Z axes
Line 953: //Traverse all edges of the box
Line 955: //Calculate the nearest point to the current edge
Line 956: //Calculate the distance
Line 957: //If the distance is shorter
Line 959: //Update the nearest point
Line 960: //Update the starting point of the line segment
Line 961: //Update the end point of the line segment
Line 962: //Update the nearest distance
Line 969: //If the nearest point is found
Line 974: //Calculate the position of the point after displacement
Line 975: //Debug.Log(moved, "#FF0000"); //Log
Line 977: //If it is the first call or the point after moving is not equal to the origin
Line 979: //Recursive call, increase the recursion depth
Line 980: //If the point after moving does not pass the test
Line 982: //Because the recursion depth has been processed in the recursion, there is no need to call CheckPoint again here
Line 983: //Return the new checkpoint
Line 985: //Return the point after moving
Line 989: //If no closer point is found, return to the origin
Line 993: //Miscellaneous
Line 1049: //The distance is the circle collider + 0.05f

File: Battle\BoardController.cs
Line 4: /// <summary>
Line 5: /// Set the baffle, the specific data is controlled in BattlePlayerController
Line 6: /// </summary>
Line 9: [Header("Width")]
Line 12: [Header("Is it a trackpad")]
Line 15: [Header("Whether to make the edge collider length vary with the sprite width")]
Line 19: //Pure detector. Detect the player on it and pinch the EdgeCollider. Specific control in BattlePlayerController
Line 20: //Default is trigger.
Line 23: //public bool test;
Line 78: //if (test) transform.position = new Vector3(Time.time, transform.position.y);
Line 95: //Enter the following

File: Battle\BulletController.cs
Line 5: /// <summary>
Line 6: /// Bullet Controller
Line 7: /// </summary>
Line 16: //Color with attributes Read enum BulletColor in BattleControl
Line 20: //public bool useExtra;
Line 21: //public Collider2D extra;
Line 22: /// <summary>
Line 23: /// Set the collision box to follow the SpriteRenderer scaling mode.
Line 24: /// CutFollow: Cut off the data stored in boxColliderSizes;
Line 25: /// NoFollow: Do not follow scaling.
Line 26: /// FullFollow: Fully follow the scaling, that is, enable automatic splicing of the box collider.
Line 27: /// </summary>
Line 41: //if (useExtra)
Line 42: // extra = GetComponent<Collider2D>();
Line 45: /// <summary>
Line 46: /// Initialize the bullet screen (single collision mode).
Line 47: /// </summary>
Line 48: /// <param name="name">Set the name of the bullet screen's Obj for easy search. </param>
Line 49: /// <param name="typeName">Set the type name of the bullet screen. If the type name is the same as the current bullet screen, the original collision-related parameters are retained, otherwise they are cleared. </param>
Line 50: /// <param name="layer">The player is 100 and the battle box edge is 50. For reference. </param>
Line 51: /// <param name="sprite">Usually imported in Resources. </param>
Line 52: /// <param name="size">Set the size of the hitbox. You can set multiple lists, but in most cases you need to avoid overlapping. (Set to (0,0) in the case of NoFollow, which will automatically synchronize with the sprite size) </param>
Line 53: /// <param name="offset">Set the hitbox offset. The List size must be equal to sizes. </param>
Line 54: /// <param name="hit">Set the collision box damage. The List size must be equal to sizes. </param>
Line 55: /// <param name="followMode">Set the collision box to follow the SpriteRenderer scaling mode. </param>
Line 56: /// <param name="startMask">Set the Sprite mask mode. </param>
Line 57: /// <param name="bulletColor">Set the bullet attribute color data</param>
Line 58: /// <param name="startPosition">Set the starting position (relative coordinates). </param>
Line 59: /// <param name="startRotation">Set the rotation angle, generally only need to change the Z axis. </param>
Line 60: /// <param name="startScale">If the bullet does not need to be stretched, StartScale is generally set to (1,1,1). When it detects that Z is 0, it will return to (1,1,1). </param>
Line 127: /// <summary>
Line 128: /// Initialize the bullet (loop to generate a box collision mode).
Line 129: /// </summary>
Line 130: /// <param name="name">Set the name of the bullet screen's Obj for easy search. </param>
Line 131: /// <param name="typeName">Set the type name of the bullet screen. If the type name is the same as the current bullet screen, the original collision-related parameters are retained, otherwise they are cleared. </param>
Line 132: /// <param name="layer">The player is 100, and the battle box edge is 50. For reference. </param>
Line 133: /// <param name="sprite">Usually imported in Resources. </param>
Line 134: /// <param name="sizes">Set the judgment box size. Multiple Lists can be set, but in most cases, it is necessary to avoid overlapping. (NoFollow is set to (0,0), which will automatically synchronize with the sprite size) </param>
Line 135: /// <param name="offsets">Set the judgment box offset, the List size must be equal to sizes. </param>
Line 136: /// <param name="hits">Set the collision box damage, the List size must be equal to sizes. </param>
Line 137: /// <param name="followMode">Set the collision box to follow the SpriteRenderer scaling mode. </param>
Line 138: /// <param name="startMask">Set the Sprite mask mode. </param>
Line 139: /// <param name="bulletColor">Set the bullet attribute color data </param>
Line 140: /// <param name="startPosition">Set the starting position (relative coordinates). </param>
Line 141: /// <param name="startRotation">Set the rotation angle, usually only need to change the Z axis. </param>
Line 142: /// <param name="startScale">If the bullet screen does not need to be stretched, StartScale is usually set to (1,1,1). When Z is detected to be 0, it will return to (1,1,1). </param>
Line 195: //Loop to generate box collisions
Line 229: //Damage determination
Line 233: //if(!useExtra)

File: Battle\BulletShaderController.cs
Line 4: /// <summary>
Line 5: /// µ¯Ä»Shader¿ ØÖÆÆ÷
Line 6: /// </summary>

File: Battle\CameraShake.cs
Line 12: [Header("moveExtent's Y axis corresponds to the camera's Z axis")]
Line 32: /// <summary>
Line 33: /// Camera shake
Line 34: /// loops will automatically convert to even numbers.
Line 35: /// </summary>

File: Battle\DialogBubbleBehaviour.cs
Line 4: /// <summary>
Line 5: /// Control of enemy dialogue bubbles in battle
Line 6: /// </summary>
Line 30: /// <summary>
Line 31: /// Change the size of the bubble and the left and right arrows, assign values, etc.
Line 32: /// </summary>

File: Battle\EnemiesController.cs
Line 3: /// <summary>
Line 4: /// Monster control script
Line 5: /// Mainly used for animation control and storage of ATKDEF
Line 6: /// </summary>

File: Battle\EnemiesHpLineController.cs
Line 7: [Header("0¿ª")]

File: Battle\GameoverController.cs
Line 7: /// <summary>
Line 8: /// Gameover controller
Line 9: /// </summary>
Line 41: // Next, let Animator perform
Line 81: //m_ParticleSystem.transform.position = new Vector3(UnityEngine.Random.Range(-6.85f, 6.85f), UnityEngine.Random.Range(-5.25f, 5.25f));

File: Battle\ItemSelectController.cs
Line 5: /// <summary>
Line 6: /// Literal meaning
Line 7: /// </summary>
Line 18: //SelectUIController selectUIController;
Line 21: //selectUIController = transform.parent.GetComponent<SelectUIController>();
Line 34: // Up

File: Battle\ProjectionCheckCollider.cs
Line 5: /// <summary>
Line 6: /// Determination of the original center of the projection.
Line 7: /// If you place the bullet comment directly at the original center position (minus one thousand), it may cause display problems.
Line 8: /// </summary>
Line 14: // Start is called before the first frame update
Line 27: // Update is called once per frame

File: Battle\SelectUIController.cs
Line 7: /// <summary>
Line 8: /// UI controller in Battle scene
Line 9: /// Also responsible for controlling the player's turn
Line 10: /// </summary>
Line 16: [Header("HP bar color")]
Line 22: [Header("number of dialogue bubbles loaded")]
Line 22: //Load actSave
Line 27: [Header("Temporarily save unused Sprite")]
Line 33: [Header("Four button UI selection 0 open")]
Line 36: [Header("Layer")]
Line 37: //0 Select button 1 Select name 2 Act option/backpack layer 3 Execution layer Reset to zero after entering the enemy's turn
Line 39: [Header("Subselect")]
Line 42: //Item&Mercy: 1 2 3 three positions ACT: four positions
Line 47: [Header("Temporarily save ACT options for easy recall")]
Line 50: [Header("Automatically search for monsters with overall combat control. Ensure consistent names")]
Line 59: [Header("Play custom turn text when entering a turn for the first time")]
Line 125: //Enemy turn: On!
Line 139: /// <summary>
Line 140: /// UI typing. After typing is completed, the text will not be forced to freeze.
Line 141: /// </summary>
Line 147: /// <summary>
Line 148: /// Tactical swap
Line 149: /// </summary>
Line 157: /// <summary>
Line 158: /// Settings when selectUI=1
Line 159: /// Mainly for selecting monsters
Line 160: /// </summary>
Line 176: /// <summary>
Line 177: /// Enter my turn
Line 178: /// </summary>
Line 195: /// <summary>
Line 196: /// My turn! Draw card)
Line 197: /// </summary>
Line 263: //if (hpFood != MainControl.instance.PlayerControl.hp)
Line 295: //FIGHT: Select enemy
Line 309: //ACT: Select enemy
Line 342: //ITEM: Jump 2
Line 353: //MERCY: Select enemy
Line 427: //Write ACT related trigger code here
Line 429: //Monster 0
Line 430: //Options
Line 453: //Monster 1
Line 454: //Options
Line 474: //Monster 2
Line 475: //Options
Line 540: //hpSpr.material.SetFloat("_Crop", 1);
Line 566: //if (myItemMax < number)
Line 718: //if (selectUI == 1)
Line 719: // KeepDialogBubble();
Line 790: /// <summary>
Line 791: /// Update UI text and health bar
Line 792: /// </summary>
Line 845: /// <summary>
Line 846: /// Solve the problem that hpUI displays 01 as 1)
Line 847: /// </summary>

File: Battle\SpriteSplitController.cs
Line 5: /// <summary>
Line 6: /// Contains Pool.
Line 7: /// Realize the fragmentation effect of the sprite.
Line 8: /// Line by line from top to bottom.
Line 9: /// This script will take effect immediately after activation
Line 10: /// </summary>
Line 13: //Object pool
Line 18: //The particle is the relative coordinate of the upper left corner of the image
Line 19: //Particle generation speed
Line 74: //-----Object pool part-----
Line 76: /// <summary>
Line 77: /// Initialize/fill the object pool
Line 78: /// </summary>
Line 88: /// <summary>
Line 89: /// Return to the object pool
Line 90: /// </summary>
Line 98: /// <summary>
Line 99: /// Get the object square)
Line 100: /// </summary>

File: Battle\SpriteSplitFly.cs
Line 4: /// <summary>
Line 5: /// SpriteSplitController's child controller
Line 6: /// </summary>

File: Battle\TargetController.cs
Line 5: /// <summary>
Line 6: /// Control Target
Line 7: /// </summary>
Line 13: [Header("Damage caused by attack")]
Line 20: [Header("Parent passed")]
Line 23: [Header("Parent passed Monster to hit")]
Line 40: //anim.enabled = true;
Line 61: /// <summary>
Line 62: /// Calculation when attacking the enemy
Line 63: /// </summary>
Line 68: //Accuracy coefficient
Line 73: //Accuracy coefficient
Line 91: //The following are all used for anim
Line 113: //anim.enabled = false;

File: Battle\TurnController.cs
Line 7: /// <summary>
Line 8: /// Turn control, also the object pool of bullet screen
Line 9: /// </summary>
Line 19: //public List<string> inheritList = new List<string>();
Line 31: //OutYourTurn();
Line 32: //Bullet screen
Line 39: //Baffle
Line 52: /// <summary>
Line 53: /// Enter the enemy's turn
Line 54: /// </summary>
Line 61: /// <summary>
Line 62: /// Turn execution system
Line 63: /// Execute according to the turn number
Line 64: /// </summary>
Line 71: //MainControl.instance.battlePlayerController.ChangePlayerColor(MainControl.instance.BattleControl.playerColorList[5], BattleControl.PlayerColor.blue,0,BattlePlayerController.PlayerDirenum.down);
Line 110: //Example round
Line 157: /// <summary>
Line 158: /// Round nesting
Line 159: /// First define the nested name in the enumeration Nest, and then write the nested content here
Line 160: /// Used for repeated nesting of complex bullet screens
Line 161: /// </summary>

File: Control\AudioControl.cs
Line 10: //public List<AudioClip> bgmClip;
Line 11: [Header("For UI sound effects")]
Line 14: [Header("For typewriter sound effects")]
Line 17: [Header("For combat sound effects")]
Line 20: [Header("For walking footsteps sound effects")]

File: Control\BattleControl.cs
Line 4: /// <summary>
Line 5: /// Battle system manager, only used in battle scenes.
Line 6: /// </summary>
Line 10: [Header("Enemy OBJ")]
Line 11: [Header("Object name will be recognized as enemy name")]
Line 12: //Enemy's Obj.
Line 14: [Header("HP, even is the current HP, odd is the maximum Max, the same below")]
Line 19: [Header("UIText read in battle")]
Line 24: [Header("Store ACT options and text after selection")]
Line 25: //4-to-one correspondence, sorted by enemies
Line 27: [Header("Store MERCY options and text after selection")]
Line 30: [Header("Store narration by turn")]
Line 33: [Header("Store enemy dialogue file")]
Line 34: //Read directly in the battle scene
Line 38: /// <summary>
Line 39: /// Barrage color data (original special barrage), non-visual color
Line 40: /// </summary>
Line 51: /// <summary>
Line 52: /// Player data color
Line 53: /// </summary>
Line 67: [Header("Item Attachment")]

File: Control\ItemControl.cs
Line 4: /// <summary>
Line 5: /// Stores all item information.
Line 6: /// </summary>
Line 10: //Data package (built-in data import)
Line 11: //Language package
Line 12: //Total List storage will be assigned to MainControl
Line 14: //@ + name/attribute1/attribute2 List is sorted as ID 3 loops 0+ 2 loops 10000+ 2 loops 20000+ 3 loops 30000+
Line 16: //-------------------------------------------------------
Line 18: //Box data storage number

File: Control\OverworldControl.cs
Line 4: /// <summary>
Line 5: /// Mainly used for Overworld data and general basic data
Line 6: /// </summary>
Line 10: //public int languagePack;
Line 11: //Prevent player operations from causing errors when the screen is black
Line 13: [Header("--UI--")]
Line 14: [Header("Font storage")]
Line 17: [Header("Font full and half width")]
Line 18: //Font full and half width
Line 20: [Header("Resolution level")]
Line 21: //Resolution level
Line 23: [Header("Full screen")]
Line 24: //Full screen switch
Line 26: [Header("Global volume")]
Line 27: //Global volume
Line 29: [Header("Simplified special effects")]
Line 30: //Light effect Post-processing special effects display
Line 32: [Header("Show FPS")]
Line 33: //Show FPS
Line 35: [Header("Resolution (for display)")]
Line 36: //Resolution
Line 38: [Header("Text packet reading")]
Line 46: //According to the setting order
Line 48: [Header("Player related")]
Line 51: [Header("Scene connection storage")]
Line 56: [Header("HD border")]
Line 61: //[Header("The data that needs to be saved in the game is written below")]
Line 62: [Header("Vertical sync")]
Line 67: // Asynchronous
Line 68: // Synchronize to the screen refresh rate
Line 69: // Synchronize to half of the screen refresh rate
Line 81: //These three
Line 82: //Yes
Line 83: //AI did it

File: Control\PlayerControl.cs
Line 4: /// <summary>
Line 5: /// Player information
Line 6: /// And some related settings
Line 7: /// </summary>
Line 14: [Header("AT and DF displayed in OW backpack will be -10")]
Line 20: //Player backpack data storage number
Line 26: [Header("Scene connection storage")]
Line 31: [Header("Open debugging")]
Line 34: [Header("--Debug mode settings--")]
Line 35: [Header("Lock blood")]

File: Debug\DebugDraft.cs
Line 8: // Start is called before the first frame update
Line 13: // Update is called once per frame

File: Debug\DebugGrid.cs
Line 4: /// <summary>
Line 5: /// Debug grid positioning, used for bullet screens
Line 6: /// </summary>
Line 9: [Header("Color is given to the 'bar'")]
Line 16: [Header("How many pieces are divided horizontally and vertically (number of knives - 1) X is horizontally laid vertical strips, Y is the opposite")]
Line 21: [Header("XY offset, if left-right symmetric, fill in a positive number like the reference")]
Line 26: [Header("reference coordinates")]
Line 48: //x
Line 52: //Debug.Log(length);
Line 64: //x
Line 68: //Debug.Log(length);

File: Debug\DebugPolygonScaler.cs
Line 6: // Used to draw the original polygon
Line 7: // Used to draw the moved polygon
Line 8: // Distance to move to the center
Line 9: // Create a simple list of polygon vertices
Line 22: // Calculate the midpoint of the polygon and move the vertex
Line 25: // Draw the original polygon
Line 28: // Draw the moved polygon
Line 32: // Method to move the polygon vertex to the center
Line 39: // Direction from the vertex to the center
Line 40: // Move a fixed distance to the center
Line 46: // Method to calculate the center of the polygon
Line 57: // Method to draw the polygon using LineRenderer
Line 60: // Set the number of vertices (+1 is to close the polygon)
Line 65: // Closed polygon

File: Debug\DebugRandomSudoku.cs
Line 6: //æ≈π¨∏Ò≤‚ ‘
Line 30: ///Debug.Log(j + 1);

File: Debug\DebugSpTextSummon.cs
Line 4: /// <summary>
Line 5: /// Generate a series of encrypted texts
Line 6: /// </summary>
Line 19: /// <summary>
Line 20: /// Convert the original letter text to numbers
Line 21: /// </summary>
Line 44: /// <summary>
Line 45: /// The first letter of the number represents the number
Line 46: /// Convert the number to letters
Line 47: /// </summary>
Line 68: /// <summary>
Line 69: /// 26 letters converted to nine-key numbers
Line 70: /// </summary>
Line 91: /// <summary>
Line 92: /// Please note when reversing
Line 93: /// </summary>

File: Debug\DebugVideoController.cs
Line 23: //Debug.Log("video play");
Line 28: //Debug.Log("video pause");
Line 35: //Debug.Log("video +");
Line 36: //Debug.Log("frame:" + videoPlayer.frame);
Line 42: //Debug.Log("video -");
Line 43: //Debug.Log("frame:" + videoPlayer.frame);
Line 48: //Debug.Log("video skip");

File: Default\AudioController.cs
Line 6: /// <summary>
Line 7: /// Control audio based on object pool
Line 8: /// </summary>
Line 39: //AudioPlayer is a subclass!! It is not built-in Unity
Line 72: //AudioPlayer is a subclass!! Not built-in Unity

File: Default\BoxController.cs
Line 5: /// <summary>
Line 6: /// Battle box master control
Line 7: /// </summary>
Line 11: [Header("Line width")]
Line 14: [Header("Generate box at the beginning, no generation if name is empty")]
Line 21: //Intersection/non-overlapping/overlapping
Line 107: //Get the realPoints of two Boxes
Line 111: //Calculate three major Lists
Line 121: //Merge two special boxes when they overlap, and give the rest to the parent BoxDrawer.
Line 146: //Delete first, add it back to the parent BoxDrawer
Line 151: //Generate first
Line 157: //List<Vector2> pointsFinal = SortPoints(CalculatePolygonCenter(AddLists(pointsCrossSave, pointsInCrossSave)), points);
Line 221: /// <summary>
Line 222: /// Generate box
Line 223: /// </summary>
Line 266: // Rotate each point first, then add the position of the object
Line 281: // The core code: build Mesh! !
Line 288: /// <summary>
Line 289: /// Calculate coordinates to get RealPoints
Line 290: /// </summary>
Line 296: // Rotate each point first, then add the position of the object
Line 307: /// <summary>
Line 308: /// Reset frame
Line 309: /// </summary>
Line 334: /// <summary>
Line 335: /// Construct Mesh
Line 336: /// </summary>
Line 340: // Convert Vector array to ContourVertex array required by LibTessDotNet
Line 347: // Create Tess object and add contour
Line 351: // Perform triangulation
Line 354: // Create Mesh object
Line 357: // Convert Tess result to Unity Mesh format
Line 370: // Apply vertices and triangles to the mesh
Line 374: // Set UV coordinates for the mesh
Line 378: // Here is a simple mapping from vertex coordinates to UV space
Line 379: // Usually, you need to adjust this code according to your specific situation
Line 388: // For better rendering, you can calculate normals and bounds
Line 392: // Apply the mesh to the GameObject
Line 395: /// <summary>
Line 396: /// Remove duplicates
Line 397: /// </summary>
Line 400: // Use HashSet<Vector2> to store the Vector2 elements that have been encountered, because HashSet automatically removes duplicates
Line 402: // Used to store the list after removing duplicates
Line 407: // If the addition to the HashSet is successful (that is, the element has not been encountered before), add it to the result list
Line 420: /// <summary>
Line 421: /// Main function, calculates all intersections of two sets of line segments
Line 422: /// </summary>
Line 430: // Loop list
Line 435: // Loop list
Line 450: /// <summary>
Line 451: /// Calculate vector cross product
Line 452: /// </summary>
Line 458: /// <summary>
Line 459: /// Check if point C is on line segment AB
Line 460: /// </summary>
Line 466: /// <summary>
Line 467: /// Check if line segments AB and CD intersect
Line 468: /// </summary>
Line 480: /// <summary>
Line 481: /// Calculate the intersection of two line segments AB and CD
Line 482: /// </summary>
Line 488: // Calculate the parameters of the linear equation
Line 491: // Line segments are parallel or collinear
Line 496: /// <summary>
Line 497: /// Calculate non-coincident points
Line 498: /// </summary>
Line 504: // Merge the list after elimination
Line 543: /// <summary>
Line 544: /// Take initialPoint as the center of the circle, a certain length as the radius, rotate clockwise, and sort the points in the list.
Line 545: /// </summary>
Line 554: /// <summary>
Line 555: /// Add the first two and subtract the last two
Line 556: /// </summary>
Line 565: /// <summary>
Line 566: /// Add List
Line 567: /// </summary>
Line 574: /// <summary>
Line 575: /// Subtract List
Line 576: /// </summary>
Line 589: //Clipper2 API related
Line 596: //X
Line 600: //Y
Line 621: /// <summary>
Line 622: /// Intersection
Line 623: /// </summary>

File: Default\BoxDrawer.cs
Line 10: /// <summary>
Line 11: /// Battle box drawing
Line 12: /// </summary>
Line 29: [Header("Don't use Transform's rotation")]
Line 30: // Get the rotation of the current object
Line 31: [Header("Line width")]
Line 35: [Header("Whether to enable Bessel interpolation")]
Line 39: [Header("The points used for the real group box")]
Line 40: // Real curve interpolation, the number of insertion points is determined by besselPointsnumber
Line 49: [Header("Set whether it is a special box")]
Line 52: [Header("When the Box is the parent, it is used to store the relevant calculated data of the child")]
Line 53: [Header("The sum of the child realPoints")]
Line 56: [Header("Intersection")]
Line 58: [Header("non-overlapping point")]
Line 60: [Header("overlapping point")]
Line 61: //Intersection/non-overlapping point/overlapping point
Line 63: //Compound parent of this box
Line 64: //Child of this box
Line 67: [Header("For Editor")]
Line 70: [Header("Whether to display Mesh (red line)")]
Line 77: //BoxController.instance.boxes.Add(this);
Line 96: //float testTimer;
Line 145: //As a pure child
Line 154: //As a parent
Line 159: //Update the position coordinates of the two children
Line 169: //Calculate the three major lists
Line 178: //Merge when overlapping
Line 199: //Dissolve if not overlapping
Line 212: //Generate a box only when the parent object is BoxController
Line 216: //Reduced frame is not drawn
Line 222: //The father of the one who left will trigger this
Line 224: //Debug.Log(transform.childCount);
Line 262: //SubListsWhenExitParent(GetRealPoints());
Line 269: //The function is used to add two quaternions
Line 272: //Convert two quaternions to Euler angles and add them
Line 277: //Convert the added Euler angles to quaternions
Line 289: /// <summary>
Line 290: ///Generate a box through BoxController
Line 291: /// </summary>
Line 302: /// <summary>
Line 303: /// Switch component
Line 304: /// </summary>
Line 307: //meshFilter.mesh = null;
Line 308: //lineRenderer.positionCount = 0;
Line 320: /// <summary>
Line 321: /// Get component
Line 322: /// </summary>
Line 323: ///
Line 341: /// <summary>
Line 342: /// Interpolation function
Line 343: /// </summary>
Line 344: /// <param name="points">Original List</param>
Line 345: /// <param name="interpolation">number of points to divide by two</param>
Line 346: /// <returns></returns>
Line 370: // Insert interpolation between the beginning and the end
Line 380: /// <summary>
Line 381: /// Generate points on the Bezier curve
Line 382: /// </summary>
Line 388: // Create a Vector2 list to store the points on the generated Bezier curve
Line 390: // Check the number of control points. At least 4 control points are required to form a cubic Bezier curve.
Line 393: // Display an error message in the console
Line 394: // Return an empty Bezier point list
Line 397: // Traverse the control point list and take out besselInsertnumber + 1 points each time to generate a Bezier curve segment
Line 405: // Generate points on the current curve segment according to the number of required points
Line 408: // Calculate the value of parameter t for interpolation
Line 409: // Call the function to calculate Bezier points
Line 410: // Add the calculated points to the Bezier point list
Line 415: // Return the generated Bezier point list
Line 433: /// <summary>
Line 434: /// Calculate the number of combinations C(n, k)
Line 435: /// </summary>
Line 460: [Header("Show the coordinates of which points")]
Line 554: // Draw a GUI once.

File: Default\CameraLightController.cs
Line 6: // Radius of visible range
Line 26: // Get references to all light source components

File: Default\CanvasController.cs
Line 10: /// <summary>
Line 11: /// UI interface, including: FPS display, long press ESC to exit, setting interface
Line 12: /// </summary>
Line 18: //Cannot be opened during enemy turn
Line 31: //Currently Max is only used to configure language packs
Line 34: //Switch levels 0th level default 1st level key settings 2nd level language pack configuration
Line 36: //Page is page turning Select is to switch primary and secondary key settings
Line 37: //Is it selected
Line 42: //Prevent trouble when switching scenes
Line 45: //Store typewriter to suspend coroutines
Line 233: //Built-in package information
Line 264: /// <summary>
Line 265: /// Get language pack information
Line 266: /// Return returnString
Line 267: /// </summary>
Line 286: /// <summary>
Line 287: /// Return on/off text
Line 288: /// </summary>
Line 324: //Settings menu
Line 778: //The time of the last frame rate update;
Line 779: //The time interval for updating the frame rate;
Line 780: //number of frames;
Line 781: //Frame rate
Line 788: //FPS = total number of frames in a certain period of time / a certain period of time
Line 797: /// <summary>
Line 798: /// Anim call
Line 799: /// </summary>
Line 809: //Convert world coordinates to screen coordinates
Line 811: //Convert screen coordinates to the center of the screen as the origin
Line 812: //Scale to get UGUI coordinates

File: Default\ChangeClipWalk.cs
Line 3: /// <summary>
Line 4: /// Change the movement range after the player triggers
Line 5: /// </summary>
Line 8: [Header("New range")]
Line 15: //PlayerBehaviour playerBehaviour = collision.transform.GetComponent<PlayerBehaviour>();

File: Default\DrawFrameController.cs
Line 6: /// <summary>
Line 7: /// Use LineRenderer and polygon shader to draw polygon frames, used for battle frames, UI, etc.
Line 8: /// </summary>
Line 12: [Header("Line length")]
Line 15: [Header("number of vertices")]
Line 18: [Header("Vertices")]
Line 21: [Header("Enable collision (for combat box)")]
Line 24: [Header("ID detection: use _Point (0)")]
Line 27: [Header("Use this to make it draw a regular polygon when it is created")]
Line 30: [Header("Turn off automatic material acquisition")]
Line 118: // Top-left
Line 119: // Top-right
Line 120: // Bottom-left
Line 121: // Bottom-right
Line 130: // Determine the number of sides based on the number of points
Line 156: // Calculate the new positions for the points
Line 164: // Apply the animations using DOTween

File: Default\DynamicTMP.cs
Line 4: /// <summary>
Line 5: /// Add all kinds of weird deformation/displacement/shake to the font. Balabala
Line 6: /// </summary>
Line 29: //Parkinson's, but each shake is different
Line 40: //Animation
Line 46: //Similar to the original battle dialogue shake: the characters shake randomly at random times
Line 60: //Animation
Line 67: //Uniform shake
Line 79: //Animation
Line 85: //Twitching shake
Line 95: //Animation
Line 106: //Ghost-like twitching shake
Line 116: //Animation
Line 124: //Ghost character floating
Line 134: //Animation

File: Default\MainControl.cs
Line 13: /// <summary>
Line 14: /// Call all ScriptableObject And is responsible for importing data and language packs
Line 15: /// Also includes most commonly used functions
Line 16: /// </summary>
Line 23: //Total number of built-in language packs
Line 27: [Header("-BGM BPM settings-")]
Line 29: [Header("BGM BPM")]
Line 32: [Header("BGM BPM offset")]
Line 35: [Header("Turn on the metronome")]
Line 38: [Header("-BGM BPM calculation results-")]
Line 42: [Header("-MainControl settings-")]
Line 44: [Header("Status: Normal, in battle")]
Line 52: [Header("For reference")]
Line 53: [Header("Out of battle")]
Line 56: //[Header("In battle")]
Line 57: //public OldBoxController OldBoxController;
Line 105: /// <summary>
Line 106: /// Get the built-in language pack ID
Line 107: /// </summary>
Line 125: /// <summary>
Line 126: /// Load the data of the corresponding language pack
Line 127: /// </summary>
Line 151: //Call ScriptableObject
Line 152: //--------------------------------------------------------------------------------
Line 155: //Call OverworldControl in InitializationOverworld
Line 156: //Call ItemControl in Initialization
Line 157: //--------------------------------------------------------------------------------
Line 160: /// <summary>
Line 161: /// Initialize and load a lot of data
Line 162: /// </summary>
Line 173: //ItemControl loading
Line 174: //--------------------------------------------------------------------------------
Line 188: //--------------------------------------------------------------------------------
Line 206: //OverworldControl loading
Line 207: //--------------------------------------------------------------------------------
Line 219: //--------------------------------------------------------------------------------
Line 228: //Detect language pack full and half width
Line 245: //BattleControl loading
Line 246: //--------------------------------------------------------------------------------
Line 284: //--------------------------------------------------------------------------------
Line 285: //OldBoxController = GameObject.Find("MainFrame").GetComponent<OldBoxController>();
Line 348: //CanvasController.instance.frame.DOKill();
Line 349: //CanvasController.instance.frame.DOColor(Color.white, 0.5f);
Line 369: /// <summary>
Line 370: /// Generate a random color in string form.
Line 371: /// </summary>
Line 382: /// <summary>
Line 383: /// Generate a random color in string form.
Line 384: /// </summary>
Line 432: /// <summary>
Line 433: /// Calculate BGM beats
Line 434: /// </summary>
Line 444: // Calculate the time point of each beat until the music duration is reached
Line 455: /// <summary>
Line 456: /// Control the metronome
Line 457: /// </summary>
Line 493: /// <summary>
Line 494: /// Apply default key positions
Line 495: /// </summary>
Line 546: /// <summary>
Line 547: /// Pass in the default KeyCode and convert it to the in-game key position.
Line 548: /// mode: 0 press 1 hold 2 lift
Line 549: /// </summary>
Line 686: /// <summary>
Line 687: /// SFX on/off
Line 688: /// </summary>
Line 715: /// <summary>
Line 716: /// Press tab to change resolution))
Line 717: /// </summary>
Line 737: /// <summary>
Line 738: /// Conversion matching resolution setting
Line 739: /// </summary>
Line 742: //if (OverworldControl.background)
Line 743: // y = y / 9 * 16;
Line 744: //else
Line 749: //Generally CanvasController.instance.framePic
Line 762: /// <summary>
Line 763: /// Resolution settings
Line 764: /// </summary>
Line 794: // BackpackBehaviour rawImage is controlled in its script
Line 821: // BackpackBehaviour rawImage is controlled in its script
Line 834: // Set in SetCanvasFrameSprite
Line 835: //CanvasController.instance.frame.sprite = OverworldControl.frames[CanvasController.instance.framePic];
Line 894: /// <summary>
Line 895: /// Fade out Enter the jump scene name
Line 896: /// banMusic is faded out
Line 897: /// time>0 has animation =0 directly cut scene <0 will be the absolute value of time
Line 898: /// </summary>
Line 955: /// <summary>
Line 956: /// Pass in a string and return a string with the last i characters deleted
Line 957: /// </summary>
Line 964: /// <summary>
Line 965: /// Randomly generate a six-digit English
Line 966: /// </summary>
Line 981: //Saved list imported text
Line 1009: /// <summary>
Line 1010: /// Import data (pass in TextAsset)
Line 1011: /// </summary>
Line 1012: //Saved list imported text
Line 1038: /// <summary>
Line 1039: /// Import data (pass in string)
Line 1040: /// </summary>
Line 1041: //Saved list Imported text
Line 1066: /// <summary>
Line 1067: /// Pass in which object to use the backpack
Line 1068: /// Then use it. If you hit true, the order of the backpack will be sorted.
Line 1069: /// Then let the typewriter type a word
Line 1070: /// Fill in 0 in plusText and calculate it yourself
Line 1071: /// </summary>
Line 1103: //Food
Line 1130: /// <summary>
Line 1131: /// Convert special characters
Line 1132: /// </summary>
Line 1137: //Check if there are multiple special characters that need to be called in a loop
Line 1155: //Debug.Log(list[i] +"/"+ name);
Line 1190: /// <summary>
Line 1191: /// Switch statement for detecting '<''>' symbol in ChangeItemData
Line 1192: /// </summary>
Line 1195: //Debug.Log(text + "/" + texters + "/" + isData);
Line 1202: //Enter
Line 1371: /// <summary>
Line 1372: /// Detect uppercase letters in the input text and convert them to all lowercase.
Line 1373: /// </summary>
Line 1398: /// <summary>
Line 1399: /// Detect lowercase letters in the input text and convert them to all uppercase.
Line 1400: /// </summary>
Line 1425: /// <summary>
Line 1426: /// Input a vector of the form (x, y)
Line 1427: /// If the vector is of the form (xRx, yRy) or (xrx, yry), then take a random number around R
Line 1428: /// </summary>
Line 1457: /// <summary>
Line 1458: /// Randomly separate the form of xRx / xrx / O
Line 1459: /// If there is no r or R, it will return to the original, which is very practical
Line 1460: ///
Line 1461: /// Additional addition: P/p gets the player's position and determines whether it is X or Y through isY
Line 1462: /// A certain degree of fixation is achieved through the form of xxx + xRx.
Line 1463: /// </summary>
Line 1511: //Debug.LogWarning(text.Substring(2));
Line 1512: //Debug.Log(RandomFloatChange(text.Substring(2), origin, isY, origin));
Line 1522: /// <summary>
Line 1523: /// Input a vector of the form (x,y)
Line 1524: ///
Line 1525: /// </summary>
Line 1533: /// <summary>
Line 1534: /// Input a vector of the form (r,g,b,a)
Line 1535: /// Also supports random numbers
Line 1536: /// </summary>
Line 1577: /// <summary>
Line 1578: /// Judge between number1 and number2 If it matches, return number2. Otherwise, return number1.
Line 1579: /// </summary>
Line 1595: /// <summary>
Line 1596: /// Allocate Item data
Line 1597: /// </summary>
Line 1604: //Total number of items
Line 1609: //Single item traversal Find the \ character
Line 1629: /// <summary>
Line 1630: /// A child void of ItemClassification
Line 1631: /// </summary>
Line 1659: /// <summary>
Line 1660: /// Detect the '\' character and split the text into sub-Lists
Line 1661: /// Batch process strings
Line 1662: /// </summary>
Line 1681: /// <summary>
Line 1682: /// Detect the '\' character and split the text into sub-lists
Line 1683: /// Pass in a string
Line 1684: /// </summary>
Line 1701: /// <summary>
Line 1702: /// Detect the first '\' character and pass it out
Line 1703: /// </summary>
Line 1716: /// <summary>
Line 1717: /// Reverse detection of the first '\' character and pass it out, optionally ignoring the last ; sign.
Line 1718: /// </summary>
Line 1740: /// <summary>
Line 1741: /// Used for in-game text reading
Line 1742: /// Pass in a data name and return the text package text
Line 1743: /// Give the first one and return the second one)
Line 1744: /// </summary>
Line 1758: /// <summary>
Line 1759: /// Used for in-game text reading
Line 1760: /// Pass in a data name and return all text package texts with the same name
Line 1761: /// </summary>
Line 1776: /// <summary>
Line 1777: /// Check if the first few characters of list are the same as the string screen passed in.
Line 1778: /// If the same, split the text into sub-Lists
Line 1779: /// </summary>
Line 1792: /// <summary>
Line 1793: /// Redistribute text packages
Line 1794: /// </summary>
Line 1797: //max.Clear();
Line 1834: /// <summary>
Line 1835: /// Get Item information by Id:
Line 1836: /// type: Foods Arms Armors Others Auto
Line 1837: /// number: 0 language package name
Line 1838: /// 1/2: data1/2.
Line 1839: /// Do not enter more.
Line 1840: /// Arm and Armor only have 1
Line 1841: /// </summary>
Line 1846: //Get the number name
Line 1911: //Get the name in the language pack
Line 1937: /// <summary>
Line 1938: /// Get the item data (HP, ATK, etc.) through the Id:
Line 1939: /// type：Foods Arms Armors Others Auto
Line 1940: /// justId: If checked, +xxHP/AT/DF and other information will be added
Line 1941: /// </summary>
Line 1946: //Get the number name
Line 2054: /// <summary>
Line 2055: /// After identifying 0, it will be transmitted
Line 2056: /// </summary>
Line 2071: /// <summary>
Line 2072: /// Get its id through the item data name.
Line 2073: /// type：Foods Arms Armors Others
Line 2074: /// </summary>
Line 2121: /// <summary>
Line 2122: /// Given List<Int>, return if empty
Line 2123: /// </summary>
Line 2147: /// <summary>
Line 2148: /// Randomly get -1 or 1
Line 2149: /// </summary>
Line 2162: /// <summary>
Line 2163: /// Return 1/-1 based on the positive or negative value of the number passed in.
Line 2164: /// Return 1 if 0 is passed in.
Line 2165: /// </summary>
Line 2175: /// <summary>
Line 2176: /// Given a specified length, the original string will be padded with spaces
Line 2177: /// </summary>
Line 2178: /// <param name="origin">Original string</param>
Line 2179: /// <param name="length">Return length</param>
Line 2180: /// <returns></returns>
Line 2223: // From the beginning to the part before A
Line 2224: // From the part after B to the end of the string
Line 2226: // Merge the two parts
Line 2236: //spriteRenderer.color = Color.red;
Line 2250: /// <summary>
Line 2251: /// Calculate the midpoint of the polygon
Line 2252: /// </summary>
Line 2272: /// <summary>
Line 2273: /// Generate random points on the surface of the sphere
Line 2274: /// </summary>

File: Default\MainControlSummon.cs
Line 5: /// <summary>
Line 6: /// Generate the main control and retain the generated main control when switching scenes.
Line 7: /// In this way, the data loading of MainControl is called only once.
Line 8: ///
Line 9: /// BGMControl will be generated at the same time
Line 10: /// </summary>
Line 13: [Header("-Canvas settings-")]
Line 19: [Header("-BGMControl settings-")]
Line 21: [Header("BGM audio, empty means no audio")]
Line 24: [Header("BGM volume")]
Line 27: [Header("BGM tone")]
Line 30: [Header("BGM loop playback initial state")]
Line 33: [Header("BGM BPM")]
Line 36: [Header("BGM BPM offset")]
Line 39: [Header("=Start the metronome during initialization")]
Line 42: [Header("-MainControl settings-")]
Line 44: [Header("Black field status related")]
Line 51: [Header("Additional settings for battle scenes")]
Line 99: //Debug.LogWarning("<color=yellow>Detected that there is a MainControl in this scene</color>", gameObject);
Line 115: //Generate

File: Default\MenuController.cs
Line 6: /// <summary>
Line 7: /// Control Menu, sodayo)
Line 8: /// </summary>
Line 11: [Header("Player name-LV-time-position-specific options-bottom text")]
Line 46: //tmps[2] is set in update
Line 150: //New
Line 159: //Next page

File: Default\ObjectPool.cs
Line 6: [Header("number of objects to fill the object pool")]
Line 13: /// <summary>
Line 14: /// Initialize/fill the object pool
Line 15: /// </summary>
Line 28: /// <summary>
Line 29: /// Return to the object pool
Line 30: /// </summary>
Line 41: /// <summary>
Line 42: /// Get the object
Line 43: /// </summary>

File: Default\RenameController.cs
Line 281: //Volume v = GameObject.Find("Global Volume").transform.GetComponent<Volume>();
Line 284: //DOTween.To(() => v.weight, x => v.weight = x, 0, 5.5f).SetEase(Ease.Linear);

File: Default\SaveController.cs
Line 7: /// <summary>
Line 8: /// Archive stored data
Line 9: /// </summary>
Line 16: //Debug.Log("save");
Line 19: //Debug.Log("create");
Line 23: // Convert data
Line 29: // Read user data into memory
Line 32: //Debug.Log("load");
Line 36: // Check if the user profile exists
Line 40: // Use CreateInstance method
Line 41: // Use PopulateObject method to fill data
Line 55: //Debug.Log("Who knows about this, my friends" + Application.dataPath + "/Data");
Line 73: // Check if the archive exists
Line 76: // Remove archive data from memory
Line 82: // Delete file
Line 102: // Get all archive file paths in the directory
Line 105: // Sort by file name
Line 120: // Rename the file

File: Default\StartController.cs
Line 5: /// <summary>
Line 6: /// Controller of the initial scene (template information)
Line 7: /// </summary>

File: Default\StorySceneController.cs
Line 6: /// <summary>
Line 7: /// ¿ØÖÆ½²¹ÊÊÂ³¡ ¾°£¨²¥PPT£©
Line 8: /// </summary>

File: Default\TextChanger.cs
Line 5: /// <summary>
Line 6: /// Used for font matching and bilingual font data correction
Line 7: /// </summary>
Line 10: //public TMP_FontAsset assetback;
Line 13: //If Chinese and English are mixed, true is enough
Line 15: [Header("US/CN")]
Line 18: //public float[] sizes;
Line 20: //public bool no = true;

File: Default\TypeWritter.cs
Line 13: /// <summary>
Line 14: /// Typewriter system
Line 15: /// </summary>
Line 19: //Is the typewriter running?
Line 20: //Is it typing characters?
Line 25: //Actually counting
Line 27: //Sound effects
Line 30: [Header("Typing speed and typing speed after detecting pause characters")]
Line 33: [Header("How many seconds after typing can you press X to skip, 0 means you can't skip")]
Line 34: //Settings
Line 41: [Header("Adapt to OW frame")]
Line 50: [Header("Font")]
Line 53: [Header("Typing animation")]
Line 56: [Header("There are always some situations that require tough measures (drawing a gun")]
Line 70: //Normal typewriter
Line 71: //Typewriter that can't press ZX, use rich text for control.
Line 76: /// <summary>
Line 77: /// Start the typewriter. If typing is in progress, you can force it to end.
Line 78: /// Generally, there is no need to forcefully interrupt the conversation.
Line 79: /// If the statement passed in contains <autoFood>, please enter hp. If you enter 0, this character will be skipped.
Line 80: /// </summary>
Line 295: //When there is only one Stop, isTyping is not set. This is because sometimes the stop time is very short, and if true, it looks a bit strange.
Line 296: //If a long Stop is required, it is recommended that you use the <stop*x> method.
Line 297: //isTyping = false;
Line 328: //passTextString += spText.Length * 2 - 5;
Line 330: //Rich text
Line 361: //string cantString = ",.:;!?，。：；！？ \n\r";
Line 406: // == '<'
Line 414: //pressX = false;
Line 417: //This is a label note
Line 427: //Animation related
Line 456: //Animation
Line 484: //pause will be used when OW detects
Line 500: //Jumping words

File: Obsolete\CreateQuadChanged.cs
Line 6: /// <summary>
Line 7: /// Old battle frame drawing script: Deprecated
Line 8: /// New: DrawFrame
Line 9: /// </summary>
Line 21: //public float debug;
Line 27: //public bool havePoints;
Line 28: //public List<Vector3> noHavePoints = new List<Vector3>();
Line 87: // Set main texture

File: Overworld\BackpackBehaviour.cs
Line 5: /// <summary>
Line 6: /// Manage OW backpack system
Line 7: /// </summary>
Line 132: // Disable
Line 136: // Enable
Line 244: //Debug.LogWarning(talkUI.transform.localPosition.z);
Line 282: // Border adaptation
Line 400: //Debug.Log(talkUI.transform.localPosition.z);

File: Overworld\CameraFollowPlayer.cs
Line 3: /// <summary>
Line 4: /// Overworld camera follow
Line 5: /// </summary>
Line 9: //Limit the maximum XY range of the camera. 0 means no movement
Line 10: //Limit the maximum XY range of the camera. 0 means no movement
Line 27: //Follow the player
Line 40: //Limit range

File: Overworld\OverworldObjTrigger.cs
Line 9: /// <summary>
Line 10: /// OWObj trigger related. Cooperate with player ray
Line 11: /// Used to read and display text and then display it
Line 12: /// </summary>
Line 16: //If true, it will be triggered when it touches. If false, press Z to trigger.
Line 23: [Header("Detect player animation direction 0,0 is not detected")]
Line 26: [Header("Save related")]
Line 33: [Header("Insert camera animation related")]
Line 42: [Header("Fill in positive time if you need to fade out")]
Line 45: [Header("OW jump scene only for trigger")]
Line 52: [Header("OW jump scene locks the direction when entering 0 None -1 Left and Right 1 Up and Down")]
Line 58: [Header("Call animator and set down to true when it ends")]
Line 64: [Header("The object closes itself when it ends")]
Line 67: [Header("Confirm the current typing object")]
Line 70: [Header("Execute method when it ends")]
Line 139: //See PlayerBehaviour for detection
Line 201: /// <summary>
Line 202: /// Activate typing. Don't touch the second parameter
Line 203: /// </summary>

File: Overworld\OverworldTalkSelect.cs
Line 6: /// <summary>
Line 7: /// Used to insert an option system in OW, consistent with UT options, but different from DR options.
Line 8: /// Adds heart to scenes with options.
Line 9: /// Called in the text package
Line 10: /// </summary>
Line 75: //Selected the left option
Line 101: //Selected the right option

File: Overworld\PlayerBehaviour.cs
Line 4: /// <summary>
Line 5: /// Player controller in Overworld
Line 6: /// </summary>
Line 16: //Player speed The editor standard is 13 and exported as 5.5
Line 18: [Header("Sound effect interception range int")]
Line 21: [Header("Open reflection")]
Line 26: //public LayerMask mask;
Line 32: //0.1 seconds, to prevent investigation OW conflict
Line 34: //If necessary, put it on. This is because some projects have echo effects
Line 50: //mask = 1 << 6;
Line 161: //Debug.Log(obj.transform.tag);
Line 179: //Animator reference
Line 247: //if (MainControl.instance.KeyArrowToControl(KeyyCode.UpArrow, 1) && MainControl.instance.KeyArrowToControl(KeyCode.DownArrow, 1)) Line 248: //moveDirectionX = 0; Line 255: //&& !(MainControl.instance.KeyArrowToControl(KeyCode.LeftArrow, 1) | | MainControl.instance.KeyArrowToControl(KeyCode.RightArrow, 1))) File: Overworld\SpriteChanger.cs Line 5: /// <summary> Line 6: /// Changing Sprite in Overworld dialog Line 7: /// </ summary> File: Overworld\TalkUIPositionChanger.cs Line 6: /// <summary> Line 7: /// Modify the position of the dialog box in Overworld Line 8: /// </summary> Line 22: //gameObject.SetActive(false);

File: Overworld\TriggerChangeLayer.cs
Line 9: [Header("Follow the parent object's layer change and add 1")]

File: Overworld\TriggerPlayerOut.cs
Line 3: /// <summary>
Line 4: /// Newly added in V0.1.1Line 5: /// For OW with animator, execute code/play animation when the player enters/leaves.
Line 6: /// Can be adjusted in many ways, I guess Line 7: /// </summary>
Line 13: [Header("Change the Boolean value of the animation:")]
Line 16: [Header("Remove the entry detection range Execute animation")]
Line 19: [Header("Remove invalidation when the previous scene is the specified scene")]
Line 22: [Header("Set to execute when leaving the range/entering the range")]
Line 28: [Header( "Set sceneBool of the animator to true when the previous scene is the specified scene")]
Line 33: [Header("When electricOpen, electricOpen")]
Line 69: //File for animation call: Overworld\Corridor\ColumnsMove. cs
Line 3: /// <summary>
Line 4: /// Corridor column movementLine 5: /// </summary>
Line 9: //Including direction (positive and negative)

File: Volume\ChromaticAberrationComponent.cs
Line 5: /// <summary>
Line 6: /// VolumeComponent, displayed in the add listLine 7: /// </summary>
Line 14: [Header("Settings")]

File: Volume\CRTScreenComponent.cs
Line 5: /// <summary>
Line 6: /// VolumeComponent, displayed in the add listLine 7: /// </summary>
Line 14: [Header("Settings")]

File: Volume\GlitchArtComponent.cs
Line 5: /// <summary>
Line 6: /// VolumeComponent, displayed in the add listLine 7: /// </summary>
Line 14: [Header("AnalogGlitch")]
Line 19 : [Header("HorizontalShake")]
Line 24: [Header("ColorDrift")]
Line 29: [Header("VerticalJump")]

File: Volume\StretchPostComponent.cs
Line 5: /// <summary>
Line 6: /// VolumeComponent, displayed in the add list Line 7 : /// </summary>
Line 14: [Header("Settings")]